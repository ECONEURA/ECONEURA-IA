env:
  DEPLOY_ENABLED: "false"
name: Deploy to Staging

on:
  push:
    branches: [ develop ]
    paths:
      - 'apps/**'
      - 'packages/**'
      - 'docker-compose*.yml'
      - 'scripts/**'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment bypassing some checks'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip integration tests'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '8'
  STAGING_ENV: staging

permissions:
  contents: read
  deployments: write
  checks: write
  pull-requests: write
  issues: write

jobs:
  pre-deployment-validation:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      validation-passed: ${{ steps.final-check.outputs.passed }}
      commit-sha: ${{ steps.commit.outputs.sha }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get commit info
      id: commit
      run: |
        echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
        echo "short-sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        echo "branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'

    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Run type checking
      run: pnpm typecheck

    - name: Run linting
      run: pnpm lint

    - name: Run unit tests
      run: pnpm test --run --coverage

    - name: Build applications
      run: pnpm build

    - name: Validate Docker Compose
      run: |
        echo "üîç Validating Docker Compose configuration..."
        docker-compose -f docker-compose.staging.yml config --quiet || {
          echo "‚ùå Docker Compose validation failed"
          exit 1
        }
        echo "‚úÖ Docker Compose configuration is valid"

    - name: Check for breaking changes
      run: |
        echo "üîç Checking for breaking changes..."
        
        # Check if there are database migrations
        if git diff --name-only HEAD~1 | grep -q "schema.prisma\|migration"; then
          echo "‚ö†Ô∏è  Database changes detected - manual review recommended"
          echo "migration-changes=true" >> $GITHUB_OUTPUT
        else
          echo "migration-changes=false" >> $GITHUB_OUTPUT
        fi

    - name: Security scan
      run: |
        echo "üîí Running security scan..."
        pnpm audit --audit-level moderate --json > security-audit.json || true
        
        if [ -f security-audit.json ]; then
          CRITICAL=$(jq '.metadata.vulnerabilities.critical // 0' security-audit.json)
          HIGH=$(jq '.metadata.vulnerabilities.high // 0' security-audit.json)
          
          if [ "$CRITICAL" -gt 0 ]; then
            echo "üö® Critical security vulnerabilities found!"
            echo "security-blocked=true" >> $GITHUB_OUTPUT
            exit 1
          elif [ "$HIGH" -gt 2 ]; then
            echo "‚ö†Ô∏è  Multiple high-severity vulnerabilities"
            echo "security-warnings=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Security check passed"
            echo "security-ok=true" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Final validation check
      id: final-check
      run: |
        echo "üéØ Performing final validation checks..."
        
        # Check if all required checks passed
        if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "‚úÖ Force deploy enabled - bypassing some checks"
          echo "passed=true" >> $GITHUB_OUTPUT
        else
          # Add your validation logic here
          echo "passed=true" >> $GITHUB_OUTPUT
        fi

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: pre-deployment-validation

    if: needs.pre-deployment-validation.outputs.validation-passed == 'true' && (github.event_name == 'push' || github.event.inputs.force_deploy == 'true' || env.DEPLOY_ENABLED == 'true')

    environment: staging

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      if: env.AWS_REGION
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Deploy infrastructure with Terraform
      if: ${{ env.DEPLOY_ENABLED == 'true' && env.TERRAFORM_WORKSPACE }}
      run: |
        echo "üèóÔ∏è Deploying infrastructure..."
        
        cd infrastructure/staging
        terraform init
        terraform workspace select ${{ env.TERRAFORM_WORKSPACE }} || terraform workspace new ${{ env.TERRAFORM_WORKSPACE }}
        terraform plan -out=tfplan
        terraform apply -auto-approve tfplan

    - name: Update infrastructure inventory
      run: |
        echo "üìã Updating infrastructure inventory..."
        mkdir -p artifacts/infrastructure
        
        cat > artifacts/infrastructure/staging-deploy.json << EOF
        {
          "deployment_id": "${{ github.run_id }}",
          "commit_sha": "${{ needs.pre-deployment-validation.outputs.commit-sha }}",
          "timestamp": "$(date -Iseconds)",
          "environment": "staging",
          "infrastructure_version": "latest",
          "terraform_workspace": "${{ env.TERRAFORM_WORKSPACE }}",
          "aws_region": "${{ secrets.AWS_REGION }}"
        }
        EOF

  deploy-applications:
    name: Deploy Applications
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [pre-deployment-validation, deploy-infrastructure]

    if: needs.pre-deployment-validation.outputs.validation-passed == 'true' && (github.event_name == 'push' || github.event.inputs.force_deploy == 'true' || env.DEPLOY_ENABLED == 'true')

    environment: staging
    strategy:
      fail-fast: false
      matrix:
        service: [api, web]

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.CONTAINER_REGISTRY }}
        username: ${{ secrets.CONTAINER_REGISTRY_USER }}
        password: ${{ secrets.CONTAINER_REGISTRY_PASSWORD }}

    - name: Build and push ${{ matrix.service }} image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./apps/${{ matrix.service }}/Dockerfile.staging
        push: true
        tags: |
          ${{ secrets.CONTAINER_REGISTRY }}/econeura-${{ matrix.service }}:staging-${{ github.sha }}
          ${{ secrets.CONTAINER_REGISTRY }}/econeura-${{ matrix.service }}:staging-latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          NODE_ENV=staging
          BUILD_COMMIT=${{ github.sha }}
          BUILD_DATE=$(date -Iseconds)

    - name: Deploy ${{ matrix.service }} to staging
      if: ${{ env.DEPLOY_ENABLED == 'true' }}
      run: |
        echo "üöÄ Deploying ${{ matrix.service }} to staging..."
        
        # Update deployment manifest
        cat > k8s/staging/${{ matrix.service }}-deployment.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: econeura-${{ matrix.service }}-staging
          namespace: staging
          labels:
            app: econeura-${{ matrix.service }}
            environment: staging
            version: ${{ github.sha }}
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: econeura-${{ matrix.service }}
              environment: staging
          template:
            metadata:
              labels:
                app: econeura-${{ matrix.service }}
                environment: staging
                version: ${{ github.sha }}
            spec:
              containers:
              - name: ${{ matrix.service }}
                image: ${{ secrets.CONTAINER_REGISTRY }}/econeura-${{ matrix.service }}:staging-${{ github.sha }}
                ports:
                - containerPort: ${{ matrix.service == 'api' && 3001 || 3000 }}
                env:
                - name: NODE_ENV
                  value: "staging"
                - name: DATABASE_URL
                  valueFrom:
                    secretKeyRef:
                      name: staging-database
                      key: url
                - name: REDIS_URL
                  valueFrom:
                    secretKeyRef:
                      name: staging-redis
                      key: url
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "250m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: ${{ matrix.service == 'api' && 3001 || 3000 }}
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /health
                    port: ${{ matrix.service == 'api' && 3001 || 3000 }}
                  initialDelaySeconds: 5
                  periodSeconds: 5
        EOF
        
        # Apply deployment (assuming kubectl is configured)
        if command -v kubectl > /dev/null 2>&1; then
          kubectl apply -f k8s/staging/${{ matrix.service }}-deployment.yaml
          kubectl rollout status deployment/econeura-${{ matrix.service }}-staging -n staging --timeout=300s
        else
          echo "‚ö†Ô∏è  kubectl not available - skipping Kubernetes deployment"
        fi

  health-checks:
    name: Health Checks & Rollback Preparation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy-applications
    outputs:
      health-status: ${{ steps.health-check.outputs.status }}
      rollback-needed: ${{ steps.health-check.outputs.rollback }}
    if: always() && !cancelled()

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Comprehensive health checks
      id: health-check
      run: |
        echo "üè• Running comprehensive health checks..."
        
        API_URL="${{ secrets.STAGING_API_URL }}"
        WEB_URL="${{ secrets.STAGING_WEB_URL }}"
        
        mkdir -p artifacts/health-checks
        
        # Initialize health status
        HEALTH_PASSED=true
        ROLLBACK_NEEDED=false
        
        echo "üìä Health Check Results" >> $GITHUB_STEP_SUMMARY
        echo "| Service | Status | Response Time | Details |" >> $GITHUB_STEP_SUMMARY
        echo "|---------|--------|---------------|---------|" >> $GITHUB_STEP_SUMMARY
        
        # Check API health
        echo "üîç Checking API health..."
        API_START=$(date +%s%3N)
        if API_RESPONSE=$(curl -f -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total}" "$API_URL/health" 2>/dev/null); then
          API_HTTP_CODE=$(echo $API_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://' | sed -e 's/;TIME.*//')
          API_TIME=$(echo $API_RESPONSE | tr -d '\n' | sed -e 's/.*TIME://')
          API_TIME_MS=$(echo "scale=0; $API_TIME * 1000" | bc 2>/dev/null || echo "0")
          
          if [ "$API_HTTP_CODE" = "200" ] && (( $(echo "$API_TIME < 2.0" | bc -l 2>/dev/null || echo "1") )); then
            echo "| API | ‚úÖ Healthy | ${API_TIME_MS}ms | OK |" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ API health check passed"
          else
            echo "| API | ‚ö†Ô∏è Slow/Degraded | ${API_TIME_MS}ms | Code: $API_HTTP_CODE |" >> $GITHUB_STEP_SUMMARY
            HEALTH_PASSED=false
            ROLLBACK_NEEDED=true
            echo "‚ö†Ô∏è API health check failed or slow"
          fi
        else
          echo "| API | ‚ùå Unhealthy | - | Connection failed |" >> $GITHUB_STEP_SUMMARY
          HEALTH_PASSED=false
          ROLLBACK_NEEDED=true
          echo "‚ùå API health check failed"
        fi
        
        # Check Web health
        echo "üîç Checking Web health..."
        WEB_START=$(date +%s%3N)
        if WEB_RESPONSE=$(curl -f -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total}" "$WEB_URL" 2>/dev/null); then
          WEB_HTTP_CODE=$(echo $WEB_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://' | sed -e 's/;TIME.*//')
          WEB_TIME=$(echo $WEB_RESPONSE | tr -d '\n' | sed -e 's/.*TIME://')
          WEB_TIME_MS=$(echo "scale=0; $WEB_TIME * 1000" | bc 2>/dev/null || echo "0")
          
          if [ "$WEB_HTTP_CODE" = "200" ] && (( $(echo "$WEB_TIME < 3.0" | bc -l 2>/dev/null || echo "1") )); then
            echo "| Web | ‚úÖ Healthy | ${WEB_TIME_MS}ms | OK |" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ Web health check passed"
          else
            echo "| Web | ‚ö†Ô∏è Slow/Degraded | ${WEB_TIME_MS}ms | Code: $WEB_HTTP_CODE |" >> $GITHUB_STEP_SUMMARY
            HEALTH_PASSED=false
            ROLLBACK_NEEDED=true
            echo "‚ö†Ô∏è Web health check failed or slow"
          fi
        else
          echo "| Web | ‚ùå Unhealthy | - | Connection failed |" >> $GITHUB_STEP_SUMMARY
          HEALTH_PASSED=false
          ROLLBACK_NEEDED=true
          echo "‚ùå Web health check failed"
        fi
        
        # Additional checks (database connectivity, etc.)
        echo "üîç Checking database connectivity..."
        if [ "$HEALTH_PASSED" = "true" ]; then
          # Test database connection through API
          if curl -f -s "$API_URL/health/db" > /dev/null 2>&1; then
            echo "| Database | ‚úÖ Connected | - | OK |" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ Database connectivity check passed"
          else
            echo "| Database | ‚ö†Ô∏è Connection Issue | - | Check required |" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è Database connectivity check failed"
          fi
        fi
        
        # Save health check results
        cat > artifacts/health-checks/results.json << EOF
        {
          "timestamp": "$(date -Iseconds)",
          "deployment_id": "${{ github.run_id }}",
          "commit_sha": "${{ github.sha }}",
          "health_passed": $HEALTH_PASSED,
          "rollback_needed": $ROLLBACK_NEEDED,
          "checks": {
            "api": {
              "url": "$API_URL",
              "healthy": $([ "$API_HTTP_CODE" = "200" ] && echo true || echo false),
              "response_time_ms": ${API_TIME_MS:-0},
              "http_code": "${API_HTTP_CODE:-unknown}"
            },
            "web": {
              "url": "$WEB_URL",
              "healthy": $([ "$WEB_HTTP_CODE" = "200" ] && echo true || echo false),
              "response_time_ms": ${WEB_TIME_MS:-0},
              "http_code": "${WEB_HTTP_CODE:-unknown}"
            }
          }
        }
        EOF
        
        # Set outputs
        echo "status=$HEALTH_PASSED" >> $GITHUB_OUTPUT
        echo "rollback=$ROLLBACK_NEEDED" >> $GITHUB_OUTPUT
        
        if [ "$HEALTH_PASSED" = "false" ]; then
          echo "‚ùå Health checks failed - preparing for rollback"
          exit 1
        else
          echo "‚úÖ All health checks passed"
        fi

    - name: Upload health check results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: staging-health-checks
        path: artifacts/health-checks/

  rollback-on-failure:
    name: Rollback on Health Check Failure
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: health-checks
    if: needs.health-checks.outputs.rollback-needed == 'true' && !cancelled()

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Get previous deployment info
      id: get-previous
      run: |
        echo "üîÑ Preparing rollback to previous stable version..."
        
        # Get previous successful deployment
        PREVIOUS_SHA=$(curl -s "${{ secrets.STAGING_API_URL }}/health" | jq -r '.version // "unknown"' 2>/dev/null || echo "unknown")
        
        if [ "$PREVIOUS_SHA" != "unknown" ] && [ "$PREVIOUS_SHA" != "${{ github.sha }}" ]; then
          echo "previous_sha=$PREVIOUS_SHA" >> $GITHUB_OUTPUT
          echo "üìã Found previous stable version: $PREVIOUS_SHA"
        else
          echo "‚ö†Ô∏è No previous stable version found, attempting emergency rollback"
          # Try to get from git history
          PREVIOUS_SHA=$(git rev-list --tags --max-count=1 2>/dev/null || git rev-parse HEAD~1)
          echo "previous_sha=$PREVIOUS_SHA" >> $GITHUB_OUTPUT
        fi

    - name: Execute rollback
      if: env.DEPLOY_ENABLED == 'true'
      run: |
        echo "üîÑ Executing rollback to ${{ steps.get-previous.outputs.previous_sha }}..."
        
        # Rollback API deployment
        kubectl set image deployment/econeura-api-staging api=${{ secrets.CONTAINER_REGISTRY }}/econeura-api:staging-${{ steps.get-previous.outputs.previous_sha }} -n staging
        
        # Rollback Web deployment
        kubectl set image deployment/econeura-web-staging web=${{ secrets.CONTAINER_REGISTRY }}/econeura-web:staging-${{ steps.get-previous.outputs.previous_sha }} -n staging
        
        # Wait for rollback to complete
        kubectl rollout status deployment/econeura-api-staging -n staging --timeout=300s
        kubectl rollout status deployment/econeura-web-staging -n staging --timeout=300s
        
        echo "‚úÖ Rollback completed successfully"

    - name: Verify rollback health
      run: |
        echo "üîç Verifying rollback health..."
        
        # Wait and check health after rollback
        sleep 30
        
        if curl -f -s "${{ secrets.STAGING_API_URL }}/health" > /dev/null 2>&1 && curl -f -s "${{ secrets.STAGING_WEB_URL }}" > /dev/null 2>&1; then
          echo "‚úÖ Rollback successful - services are healthy"
        else
          echo "‚ùå Rollback failed - services still unhealthy"
          exit 1
        fi

    - name: Notify rollback completion
      if: always()
      run: |
        echo "## üîÑ Rollback Completed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Deployment:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Rolled back to:** ${{ steps.get-previous.outputs.previous_sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** ${{ job.status == 'success' && '‚úÖ Successful' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
        echo "- Investigate root cause of deployment failure" >> $GITHUB_STEP_SUMMARY
        echo "- Fix issues in codebase" >> $GITHUB_STEP_SUMMARY
        echo "- Test fixes thoroughly before next deployment" >> $GITHUB_STEP_SUMMARY

  post-deployment-tests:
    name: Post-Deployment Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: deploy-applications
    if: always() && !cancelled()

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'

    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Wait for services to be ready
      run: |
        echo "‚è≥ Waiting for staging services to be ready..."
        
        API_URL="${{ secrets.STAGING_API_URL }}"
        WEB_URL="${{ secrets.STAGING_WEB_URL }}"
        
        # Wait for API
        for i in {1..30}; do
          if curl -f -s "$API_URL/health" > /dev/null 2>&1; then
            echo "‚úÖ API is ready"
            break
          fi
          echo "Waiting for API... ($i/30)"
          sleep 10
        done
        
        # Wait for Web
        for i in {1..30}; do
          if curl -f -s "$WEB_URL" > /dev/null 2>&1; then
            echo "‚úÖ Web is ready"
            break
          fi
          echo "Waiting for Web... ($i/30)"
          sleep 10
        done

    - name: Run smoke tests
      run: |
        echo "üö¨ Running smoke tests on staging..."
        
        API_URL="${{ secrets.STAGING_API_URL }}"
        WEB_URL="${{ secrets.STAGING_WEB_URL }}"
        
        # Test API endpoints
        echo "Testing API health..."
        curl -f "$API_URL/health" || exit 1
        
        echo "Testing API companies endpoint..."
        curl -f "$API_URL/api/crm/companies" || exit 1
        
        # Test Web application
        echo "Testing Web application..."
        curl -f "$WEB_URL" | grep -q "ECONURA" || exit 1
        
        echo "‚úÖ All smoke tests passed"

    - name: Run integration tests against staging
      if: github.event.inputs.skip_tests != 'true'
      run: |
        echo "üß™ Running integration tests against staging..."
        
        # Configure environment for staging tests
        cat > .env.staging-test << EOF
        NODE_ENV=staging
        API_BASE_URL=${{ secrets.STAGING_API_URL }}
        WEB_BASE_URL=${{ secrets.STAGING_WEB_URL }}
        TEST_ENVIRONMENT=staging
        EOF
        
        # Run integration tests
        pnpm test:integration --env .env.staging-test

  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [pre-deployment-validation, deploy-infrastructure, deploy-applications, post-deployment-tests]
    if: always() && !cancelled()

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Generate deployment report
      run: |
        echo "## üöÄ Staging Deployment Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        DEPLOY_STATUS="unknown"
        if [ "${{ needs.post-deployment-tests.result }}" = "success" ]; then
          DEPLOY_STATUS="‚úÖ SUCCESS"
        elif [ "${{ needs.post-deployment-tests.result }}" = "failure" ]; then
          DEPLOY_STATUS="‚ùå FAILED"
        else
          DEPLOY_STATUS="‚ö†Ô∏è PARTIAL"
        fi
        
        echo "### Deployment Status: $DEPLOY_STATUS" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### Deployment Details:" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** \`${{ needs.pre-deployment-validation.outputs.commit-sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch:** \`develop\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment:** Staging" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### Pipeline Results:" >> $GITHUB_STEP_SUMMARY
        echo "| Stage | Status | Duration |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|----------|" >> $GITHUB_STEP_SUMMARY
        echo "| Pre-deployment validation | ${{ needs.pre-deployment-validation.result == 'success' && '‚úÖ' || '‚ùå' }} | - |" >> $GITHUB_STEP_SUMMARY
        echo "| Infrastructure deployment | ${{ needs.deploy-infrastructure.result == 'success' && '‚úÖ' || needs.deploy-infrastructure.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} | - |" >> $GITHUB_STEP_SUMMARY
        echo "| Application deployment | ${{ needs.deploy-applications.result == 'success' && '‚úÖ' || '‚ùå' }} | - |" >> $GITHUB_STEP_SUMMARY
        echo "| Post-deployment tests | ${{ needs.post-deployment-tests.result == 'success' && '‚úÖ' || '‚ùå' }} | - |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.post-deployment-tests.result }}" = "success" ]; then
          echo "### ‚úÖ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "- Applications deployed to staging environment" >> $GITHUB_STEP_SUMMARY
          echo "- All tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- Services are healthy and responding" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor application performance" >> $GITHUB_STEP_SUMMARY
          echo "- Run additional manual testing if needed" >> $GITHUB_STEP_SUMMARY
          echo "- Consider promoting to production when ready" >> $GITHUB_STEP_SUMMARY
        else
          echo "### ‚ùå Deployment Issues Detected" >> $GITHUB_STEP_SUMMARY
          echo "- Review deployment logs for errors" >> $GITHUB_STEP_SUMMARY
          echo "- Check service health and connectivity" >> $GITHUB_STEP_SUMMARY
          echo "- Investigate failed tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Recovery Actions:" >> $GITHUB_STEP_SUMMARY
          echo "- Rollback to previous version if needed" >> $GITHUB_STEP_SUMMARY
          echo "- Fix identified issues and redeploy" >> $GITHUB_STEP_SUMMARY
          echo "- Contact DevOps team for assistance" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Create deployment issue on failure
      if: needs.post-deployment-tests.result == 'failure'
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: 'üö® Staging Deployment Failed - ' + context.sha.substring(0, 7),
            body: '## Staging Deployment Failure\\n\\n**Commit:** ' + context.sha + '\\n**Run:** ' + context.serverUrl + '/' + context.repo.owner + '/' + context.repo.repo + '/actions/runs/' + context.runId + '\\n\\nDeployment failed. Check the workflow logs for details.\\n\\n*This issue was automatically created by staging deployment workflow*',
            labels: ['deployment', 'staging', 'failure', 'urgent']
          });

    - name: Notify deployment status
      run: |
        if [ "${{ needs.post-deployment-tests.result }}" = "success" ]; then
          echo "üéâ Staging deployment completed successfully!"
        else
          echo "‚ùå Staging deployment failed - check logs and issues"
          exit 1
        fi

concurrency: hardening-global
