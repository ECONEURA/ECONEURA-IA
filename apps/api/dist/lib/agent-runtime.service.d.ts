import { z } from 'zod';
import { EventEmitter } from 'events';
import { AgentExecutionRequest } from './ai-agents-registry.service.js';
export declare const AgentRuntimeConfigSchema: z.ZodObject<{
    maxConcurrentExecutions: z.ZodDefault<z.ZodNumber>;
    defaultTimeoutMs: z.ZodDefault<z.ZodNumber>;
    maxRetries: z.ZodDefault<z.ZodNumber>;
    retryDelayMs: z.ZodDefault<z.ZodNumber>;
    healthCheckIntervalMs: z.ZodDefault<z.ZodNumber>;
    cleanupIntervalMs: z.ZodDefault<z.ZodNumber>;
    maxExecutionHistory: z.ZodDefault<z.ZodNumber>;
    enableMetrics: z.ZodDefault<z.ZodBoolean>;
    enableTracing: z.ZodDefault<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    maxRetries?: number;
    maxConcurrentExecutions?: number;
    defaultTimeoutMs?: number;
    retryDelayMs?: number;
    healthCheckIntervalMs?: number;
    cleanupIntervalMs?: number;
    maxExecutionHistory?: number;
    enableMetrics?: boolean;
    enableTracing?: boolean;
}, {
    maxRetries?: number;
    maxConcurrentExecutions?: number;
    defaultTimeoutMs?: number;
    retryDelayMs?: number;
    healthCheckIntervalMs?: number;
    cleanupIntervalMs?: number;
    maxExecutionHistory?: number;
    enableMetrics?: boolean;
    enableTracing?: boolean;
}>;
export type AgentRuntimeConfig = z.infer<typeof AgentRuntimeConfigSchema>;
export declare const AgentTaskSchema: z.ZodObject<{
    id: z.ZodString;
    agentId: z.ZodString;
    inputs: z.ZodRecord<z.ZodString, z.ZodAny>;
    context: z.ZodObject<{
        orgId: z.ZodString;
        userId: z.ZodString;
        correlationId: z.ZodString;
        idempotencyKey: z.ZodOptional<z.ZodString>;
        metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
        budget: z.ZodOptional<z.ZodNumber>;
        priority: z.ZodOptional<z.ZodEnum<["low", "medium", "high", "critical"]>>;
    }, "strip", z.ZodTypeAny, {
        userId?: string;
        metadata?: Record<string, any>;
        orgId?: string;
        correlationId?: string;
        idempotencyKey?: string;
        priority?: "critical" | "low" | "medium" | "high";
        budget?: number;
    }, {
        userId?: string;
        metadata?: Record<string, any>;
        orgId?: string;
        correlationId?: string;
        idempotencyKey?: string;
        priority?: "critical" | "low" | "medium" | "high";
        budget?: number;
    }>;
    status: z.ZodEnum<["pending", "running", "completed", "failed", "cancelled"]>;
    priority: z.ZodDefault<z.ZodEnum<["low", "medium", "high", "critical"]>>;
    scheduledAt: z.ZodOptional<z.ZodString>;
    startedAt: z.ZodOptional<z.ZodString>;
    completedAt: z.ZodOptional<z.ZodString>;
    retryCount: z.ZodDefault<z.ZodNumber>;
    maxRetries: z.ZodDefault<z.ZodNumber>;
    timeoutMs: z.ZodDefault<z.ZodNumber>;
    dependencies: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    outputs: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    error: z.ZodOptional<z.ZodString>;
    costEur: z.ZodOptional<z.ZodNumber>;
    executionTimeMs: z.ZodOptional<z.ZodNumber>;
    createdAt: z.ZodString;
    updatedAt: z.ZodString;
}, "strip", z.ZodTypeAny, {
    error?: string;
    status?: "pending" | "completed" | "failed" | "cancelled" | "running";
    maxRetries?: number;
    context?: {
        userId?: string;
        metadata?: Record<string, any>;
        orgId?: string;
        correlationId?: string;
        idempotencyKey?: string;
        priority?: "critical" | "low" | "medium" | "high";
        budget?: number;
    };
    id?: string;
    createdAt?: string;
    updatedAt?: string;
    scheduledAt?: string;
    completedAt?: string;
    priority?: "critical" | "low" | "medium" | "high";
    costEur?: number;
    startedAt?: string;
    retryCount?: number;
    dependencies?: string[];
    agentId?: string;
    timeoutMs?: number;
    inputs?: Record<string, any>;
    outputs?: Record<string, any>;
    executionTimeMs?: number;
}, {
    error?: string;
    status?: "pending" | "completed" | "failed" | "cancelled" | "running";
    maxRetries?: number;
    context?: {
        userId?: string;
        metadata?: Record<string, any>;
        orgId?: string;
        correlationId?: string;
        idempotencyKey?: string;
        priority?: "critical" | "low" | "medium" | "high";
        budget?: number;
    };
    id?: string;
    createdAt?: string;
    updatedAt?: string;
    scheduledAt?: string;
    completedAt?: string;
    priority?: "critical" | "low" | "medium" | "high";
    costEur?: number;
    startedAt?: string;
    retryCount?: number;
    dependencies?: string[];
    agentId?: string;
    timeoutMs?: number;
    inputs?: Record<string, any>;
    outputs?: Record<string, any>;
    executionTimeMs?: number;
}>;
export type AgentTask = z.infer<typeof AgentTaskSchema>;
export declare const AgentRuntimeMetricsSchema: z.ZodObject<{
    totalExecutions: z.ZodNumber;
    successfulExecutions: z.ZodNumber;
    failedExecutions: z.ZodNumber;
    cancelledExecutions: z.ZodNumber;
    averageExecutionTime: z.ZodNumber;
    averageCost: z.ZodNumber;
    totalCost: z.ZodNumber;
    activeExecutions: z.ZodNumber;
    queuedTasks: z.ZodNumber;
    systemHealth: z.ZodEnum<["healthy", "degraded", "unhealthy"]>;
    lastUpdated: z.ZodString;
}, "strip", z.ZodTypeAny, {
    totalExecutions?: number;
    averageCost?: number;
    averageExecutionTime?: number;
    totalCost?: number;
    successfulExecutions?: number;
    failedExecutions?: number;
    cancelledExecutions?: number;
    activeExecutions?: number;
    queuedTasks?: number;
    systemHealth?: "healthy" | "unhealthy" | "degraded";
    lastUpdated?: string;
}, {
    totalExecutions?: number;
    averageCost?: number;
    averageExecutionTime?: number;
    totalCost?: number;
    successfulExecutions?: number;
    failedExecutions?: number;
    cancelledExecutions?: number;
    activeExecutions?: number;
    queuedTasks?: number;
    systemHealth?: "healthy" | "unhealthy" | "degraded";
    lastUpdated?: string;
}>;
export type AgentRuntimeMetrics = z.infer<typeof AgentRuntimeMetricsSchema>;
export interface AgentRuntimeEvents {
    'task:created': (task: AgentTask) => void;
    'task:started': (task: AgentTask) => void;
    'task:completed': (task: AgentTask) => void;
    'task:failed': (task: AgentTask, error: Error) => void;
    'task:retry': (task: AgentTask, retryCount: number) => void;
    'task:cancelled': (task: AgentTask) => void;
    'runtime:health-check': (metrics: AgentRuntimeMetrics) => void;
    'runtime:error': (error: Error) => void;
}
export declare class AgentRuntimeService extends EventEmitter {
    private config;
    private aiRouter;
    private taskQueue;
    private activeExecutions;
    private executionHistory;
    private metrics;
    private isRunning;
    private healthCheckInterval?;
    private cleanupInterval?;
    private workerPool;
    constructor(config?: Partial<AgentRuntimeConfig>);
    start(): Promise<void>;
    stop(): Promise<void>;
    submitTask(request: AgentExecutionRequest): Promise<AgentTask>;
    getTaskStatus(taskId: string): Promise<AgentTask | null>;
    cancelTask(taskId: string, reason?: string): Promise<boolean>;
    getMetrics(): AgentRuntimeMetrics;
    getActiveExecutions(): AgentTask[];
    getQueuedTasks(): AgentTask[];
    getExecutionHistory(limit?: number): AgentTask[];
    private setupEventHandlers;
    private startTaskProcessing;
    private getNextTask;
    private executeTask;
    private checkDependencies;
    private loadPendingTasks;
    private persistTask;
    private updateTaskInDatabase;
    private loadTaskFromDatabase;
    private findTaskByIdempotencyKey;
    private updateAverageMetrics;
    private performHealthCheck;
    private performCleanup;
}
export declare const agentRuntime: AgentRuntimeService;
//# sourceMappingURL=agent-runtime.service.d.ts.map